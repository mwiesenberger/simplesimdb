"""Creation and management of simple simulation data"""
import json
import hashlib # for the hashing
import os.path # to check for files
import subprocess # to run the create program


class Repeater :
    """ Manage a single file pair (inputfile, outputfile)

    The purpose of this class is to provide a simple tool when you do not want
    to actually store simulation data on disc (except temporarily). It is
    sometimes more efficient to simply write the data into a single file
    and then reuse/overwrite it in all subsequent simulations.

    """
    def __init__ (self, executable="./execute.sh", inputfile="temp.json", outputfile="temp.nc"):
        """ Set the executable and files to use in the run method"""
        self.executable = executable
        self.inputfile = inputfile
        self.outputfile = outputfile
    @property
    def executable(self):
        return self.__executable
    @property
    def inputfile(self):
        return self.__inputfile
    @property
    def outputfile(self):
        return self.__outputfile
    @executable.setter
    def executable(self, executable) :
        self.__executable = executable
    @inputfile.setter
    def inputfile(self, inputfile) :
        self.__inputfile = inputfile
    @outputfile.setter
    def outputfile(self, outputfile) :
        self.__outputfile = outputfile

    def run( self, js, error="display", stdout="ignore"):
        """ Write inputfile and then run a simulation

        error (string) :
            "raise"
            raise a subprocess.CalledProcessError error
            if the executable returns a non-zero exit code
            "display"
            print(stderr ) then return
            "ignore"
            return
        stdout (string) :
            "ignore"
            throw away std output
            "display"
            print( process.stdout)
            return
        """
        with open( self.inputfile, 'w') as f:
            inputstring = json.dump( js, f,
                    sort_keys=True, ensure_ascii=True, indent=4)
        try :
            process = subprocess.run( [self.__executable, self.__inputfile,
                    self.__outputfile],
                    check=True, capture_output=True)
            if stdout == "display" :
                print( process.stdout)
        except subprocess.CalledProcessError as e:
            if error == "display" :
                print( e.stderr)
            elif error == "raise" :
                raise e
    def clean(self) :
        """ Remove inputfile and outputfile"""
        if os.path.isfile( self.__inputfile) :
            os.remove( self.__inputfile)
        if os.path.isfile( self.__outputfile) :
            os.remove( self.__outputfile)




class Manager :
    """ Lightweight Simulation Database Manager

    Create, access and display simulation data of a given code as pairs
    (inputfile.json : outputfile [, restarted_01, restarted_02, ...]),
    where all input files are json files (converted from python dictionaries)
    and the output files (of arbitrary type) are generated by an executable
    that takes the json file as input. This executable is provided by the user
    and could for example be the program itself or a script calling it. The
    idea is to let the user define how the code should be run.

    NOTE: an executable may only take one sinlge input file and may only
    generate one single output file

    RESTART ADDON (ignore if not used):
    sometimes simulation outputs cannot be created in a single
    run (due to file size, time limitations, etc.) but rather a simulation is
    partitioned (in time) into a sequential number of separate smaller runs.
    Correspondingly each run sequentially generates and stores only a partition
    of the entire output file. Each run restarts the simulation with the result
    of the previous run. The Manager solves this problem via the
    simulation number n in its member functions. For n>0 create will pass the
    result of the previous simulation as a third input to the executable
    """

    def __init__ (self, directory = './data', filetype='nc', executable="./execute.sh"):
        """ init the Manager class

        Parameters
        directory (path) : the path of the folder this class manages.
            Folder is created if it does not exist yet.  The class will
            recognize existing files that were generated by a previous session.
        filetype (string) : file extension of the output files
        executable (string) : The executable that generates the data

        executable be called using subprocess.run([executable,
        directory/hashid.json, directory/hashid.filetype],...) with 2 arguments
        - a json file as input (do not change the input else the file is not
        recognized any more) and one output file (that executable needs to
        generate) (if your code does not take json as input you can for example
        parse json in bash using jq)

        RESTART ADDON (ignore if not used):
        If you intend to use the restart option (by passing a simulation number
        n>0 to create), executable is called with
        subprocess.run([executable, directory/hashid.json,
        directory/hashid0xN.filetype, directory/hashid0x(N-1).filetype],...)
        that is it must take a third argument (the previous simulation)
        """
        self.directory = directory
        os.makedirs( self.__directory, exist_ok=True)
        self.filetype = filetype
        self.executable = executable

    @property
    def directory(self):
        """ (path) : data directory

        If the directory does not exist it will be created """
        return self.__directory

    @property
    def executable(self):
        """
        (string) : The executable that generates the data.

        The create method calls subprocess.run([executable,
        directory/hashid.json, directory/hashid.filetype],...) that is it must
        take 2 arguments - a json file as input (do not change the input else
        the file is not recognized any more) and one output file (that
        executable needs to generate) (if your code does not take json as input
        you can for example parse json in bash using jq)

        RESTART ADDON (ignore if not used):
        If you intend to use the restart option (by passing a simulation number
        n>0 to create), the executable is called with
        subprocess.run([executable, directory/hashid.json,
        directory/hashid0xN.filetype, directory/hashid0x(N-1).filetype],...)
        that is it must take a third argument (the previous simulation)
        """
        return self.__executable

    @property
    def filetype(self):
        """ (string) : file extension of the output files """
        return self.__filetype

    @directory.setter
    def directory(self, directory) :
        self.__directory = directory
        os.makedirs( self.__directory, exist_ok=True)

    @executable.setter
    def executable(self, executable) :
        self.__executable = executable

    @filetype.setter
    def filetype(self, filetype) :
        self.__filetype = filetype

    def create( self, js, n = 0, error = "raise", stdout="ignore"):
        """Run a simulation if outfile does not exist yet

        Create (write) the in.json file to disc
        Use subprocess.run( [executable, in.json, out])
        If the executable returns a non-zero exit code the inputfile (if n!= 0)
        and outputfile are removed

        Parameters:
        js (dict): the complete input file as a python dictionary. All keys
        must be strings such that js can be converted to JSON.
        n (integer) : (RESTART ADDON) the number of the simulation to run
        beginning with 0.  If n>0, we will use the previous simulation as a
        third argument subprocess.run( [executable, in.json, out_n, out_(n-1)])
        This can be used to restart simulations
        error (string) :
            "raise"
            raise a subprocess.CalledProcessError error
            if the executable returns a non-zero exit code
            "display"
            print(stderr ) then return
            "ignore"
            return
        stdout (string) :
            "ignore"
            throw away std output
            "display"
            print( process.stdout)
            return



        ATTENTION:  in order to generate a unique identifier
        js needs to be normalized in the sense that the datatype must match
        the required datatype documented (e.g. don't write 10 in a field
        requiring float but 10.0, otherwise it is interpreted as an integer and
        thus produces a different hash)

        Return:
        string: filename of new entry if it did not exist before
                existing filename else

        """
        ncfile = self.outfile( js, n)
        exists = os.path.isfile( ncfile)
        if exists:
            return ncfile
        else :
            print( "Running simulation ..." + ncfile[-12:])
            #First write the json file into the database
            # so that the program can read it as input
            with open( self.jsonfile(js), 'w') as f:
                inputstring = json.dumps( js, sort_keys=True, ensure_ascii=True)
                f.write( inputstring)
            #Run the code to create output file
            try :
                # Check if the simulation is a restart
                if n == 0 :
                    process = subprocess.run( [self.__executable, self.jsonfile(js),
                        ncfile],
                        check=True, capture_output=True)
                    if stdout == "display" :
                        print( process.stdout)
                else :
                    previous_ncfile = self.outfile( js, n-1)
                    process = subprocess.run( [self.__executable, self.jsonfile(js),
                        ncfile, previous_ncfile],
                        check=True, capture_output=True)
                    if stdout == "display" :
                        print( process.stdout)
            except subprocess.CalledProcessError as e:
                #clean up entry and escalate exception
                if os.path.isfile( ncfile) :
                    os.remove( ncfile)
                if n == 0 : # only remove input if not restarted
                    os.remove( self.jsonfile(js))
                if error == "display" :
                    print( e.stderr)
                elif error == "raise" :
                    raise e

            return ncfile

    def select( self, js, n = 0) :
        """ Select an output file based on its input parameters

        Raise a ValueError exception if the file does not exist
        else it just returns self.outfile( js, n)

        Parameters:
        js (dict): the complete input file as a python dictionary. All keys
        must be strings such that js can be converted to JSON.
        n (integer) : (RESTART ADDON) the number of the simulation to select
        beginning with 0.

        WARNING:  in order to generate a unique identifier
        js needs to be normalized in the sense that the datatype must match
        the required datatype documented (e.g. 10 in a field requiring float
        is interpreted as an integer and thus produces a different hash)

        Return:
        string: self.outfile( js, n) if file exists
        """
        ncfile = self.outfile( js, n)
        exists = os.path.isfile( ncfile)
        if not exists:
            raise ValueError( 'Entry does not exist')
        else :
            return ncfile

    def count( self, js) :
        """ (RESTART ADDON) Count number of output files for given input

        Count the output files associated with the given input parameters that
        currently exist in directory
        (i.e. count n as long as self.exists( js, n) returns True).
        Parameters:
        js (dict): the complete input file as a python dictionary. All keys
        must be strings such that js can be converted to JSON.

        Return:
        integer: Number of simulations
        """
        number = 0
        while self.exists( js, number) :
            number += 1

        return number

    def exists( self, js, n = 0) :
        """ Check for existence of data

        Parameters:
        js (dict): the complete input file as a python dictionary. All keys
        must be strings such that js can be converted to JSON.
        n (integer) : (RESTART ADDON) the number of the simulation to select
        beginning with 0.

        Return:
        bool: True if output data corresponding to js exists, False else
        """
        ncfile = self.outfile( js, n)
        return os.path.isfile( ncfile)

    def files(self):
        """ Return a list of ids and files existing in directory

        The purpose here is to give the user an iterable object to search
        or tabularize the content of outputfiles
        Return:
        list of dict : [ {"id": id, "n", n, "inputfile":jsonfile,
            "outputfile" : outfile}]
        """

        table = []
        for filename in os.listdir(self.__directory) :
            if filename.endswith(".json") and not filename.endswith( "out.json") :
                with open( os.path.join( self.__directory, filename), 'r') as f:
                    #load all json files and check if they are named correctly
                    # and have a corresponding output file
                    js = json.load( f)
                    number = self.count( js) # count how many exist
                    for n in range( 0, number) :
                        ncfile = self.outfile( js, n)
                        entry = {
                            "id" : self.hashinput( js),
                            "n" : n,
                            "inputfile" : self.jsonfile(js),
                            "outputfile" : ncfile,
                        }
                        table.append(entry)
        return table

    def table(self):
        """ Return all exisiting (input)-data in a list of python dicts

        Use json.dumps(table(), indent=4) to pretty print
        Note that this list of dictionaries is searchable/ iteratable with standard
        python methods.
        RESTART ADDON: the input file for a restarted simulation shows only
        once

        Return:
        list of dict : [ { ...}, {...},...] where ... represents the actual
            content of the inputfiles
        """
        files = self.files()
        table=[]
        for d in files :
            with open( d["inputfile"]) as f :
                js = json.load( f)
                if d["n"] == 0 :
                    table.append( js)
        return table

    def hashinput( self, js):
        """Hash the input dictionary

        Params:
        js (dict): the complete input file as a python dictionary. All keys
        must be strings such that js can be converted to JSON.

        WARNING:  in order to generate a unique identifier
        js needs to be normalized in the sense that the datatype must match
        the required datatype documented (e.g. 10 in a field requiring float
        is interpreted as an integer and thus produces a different hash)

        Return:
        string: The hexadecimal sha1 hashid of the input dictionary
        """
        inputstring = json.dumps( js, sort_keys=True, ensure_ascii=True)
        hashed = hashlib.sha1( inputstring.encode( 'utf-8') ).hexdigest()
        return hashed

    def jsonfile( self, js) :
        """ File path to json file from the input

        Does not check if the file actually exists
        Return:
        path: the file path of the input file
        """
        hashid = self.hashinput(js)
        return os.path.join(self.__directory, hashid+'.json')

    def outfile( self, js, n = 0) :
        """ File path to output file from the input

        Do not check if the file actually exists
        Return:
        path: the file path of the output file
        """
        hashid = self.hashinput(js)
        sim_num = ""
        if n > 0 :
            sim_num = hex(n)
        if "json" == self.__filetype :
            return os.path.join( self.__directory,
                    hashid + sim_num + '_out.json')
        return os.path.join(self.__directory,
                hashid + sim_num + '.' + self.__filetype)

    def delete( self, js, n = 0) :
        """ Delete an entry if it exists """
        ncfile = self.outfile( js, n)
        exists = os.path.isfile( ncfile)
        if exists :
            os.remove( ncfile)
            if n == 0 :
                os.remove( self.jsonfile(js))

    def replace( self, js, n = 0) :
        """ Force a re-simulation: delete(js, n) followed by create(js, n) """
        self.delete(js, n)
        return self.create(js, n)


    def delete_all (self) :
        """ Delete all file pairs id'd by the files method

        and the directory itself (if empty)
        ATTENTION: if you want to continue to use the object afterwards
        remember to reset the directory: m.directory = '...'
        """
        files = self.files()
        for entry in files :
            if entry["n"] == 0 :
                os.remove( entry["inputfile"])
            os.remove( entry["outputfile"])
        try :
            os.rmdir( self.__directory)
        except OSError as e:
            pass # if the directory is non-empty nothing happens

#### Ideas on a file view class
# - for projects that are not managed or created with simplesimdb
# - We can have a class managing a view of (input.json, outfile) pairs
#   without creating files but just managing the inputs
# - problem is that inputfiles are seldom separately stored but we would rather
#   need a view of netcdf files where we can assume the input is stored inside
# - no functionality to create or delete files
# - add single files or whole folders (assuming json and nc file has the name)
